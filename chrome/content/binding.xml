<?xml version="1.0"?>
<bindings id="universal-search"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <![CDATA[
    /*
     * Override the default binding, inserting a recommendation element in
     * the popup above the list of history/suggestion results.
     */
  ]]>
  <binding id="recommendation-popup" extends="chrome://browser/content/urlbarBindings.xml#urlbar-rich-result-popup">
    <content ignorekeys="true" level="top" consumeoutsideclicks="never" aria-owns="richlistbox">
      <xul:hbox id="universal-search-recommendation" collapsed="true"/>
      <xul:richlistbox anonid="richlistbox" class="autocomplete-richlistbox" flex="1"/>
      <xul:hbox anonid="footer">
        <children/>
      </xul:hbox>
    </content>
    <implementation>
      <![CDATA[
        /*
         * Turns out we need to keep this set on the richlistbox for mousemove
         * stuff to be simple.
         * TODO: update these docs once it's sorted.
         *
         * The selectedIndex setter sets the blue highlight on the currently-
         * selected item in the results list. The existing implementation,
         * defined in autocomplete.xml, automatically closes the popup if no
         * results list items are selected (selectedIndex = -1).
         *
         * Override the setter, removing the auto-close behavior, so that the
         * universal search recommendation element can steal the highlight.
         */
      ]]>
      <property name="selectedIndex"
                onget="return this.richlistbox.selectedIndex;">
        <setter><![CDATA[
          // Naively set the value. Let the richlistbox worry about whether
          // the value actually exists in the list or not.
          this.richlistbox.selectedIndex = val;

          // Because we we aren't ensuring `val` exists, the actual
          // selectedIndex might differ from what was requested. So, we should
          // check the DOM for the final value.
          const finalVal = this.richlistbox.selectedIndex;

          // Scroll the row into view, if necessary.
          this.richlistbox.ensureIndexIsVisible(finalVal);

          return finalVal;
        ]]></setter>
      </property>

      <![CDATA[
        /*
         * The urlbar stops working if getNextIndex is not overridden here.
         * This implementation doesn't handle certain edge cases, like
         * scrolling off the top or bottom of the list, but whatever code
         * calls this code doesn't seem to hit that bug.
         */
      ]]>
      <method name="getNextIndex">
        <parameter name="reverse"/>
        <parameter name="amount"/>
        <parameter name="index"/>
        <parameter name="maxRow"/>
        <body><![CDATA[
          let realAmount = amount % maxRow;
          this.selectedIndex = reverse ? this.selectedIndex - realAmount : this.selectedIndex + realAmount;
          return this.selectedIndex;
        ]]></body>
      </method>
    </implementation>
    <handlers>
      <handler event="mousemove" phase="capturing"><![CDATA[
        // let's just see if we can steal the mousemove focus by overriding this
        // one handler.
        // TODO: I don't think we need this?
        event.preventDefault();
      ]]></handler>
    </handlers>
  </binding>

  <![CDATA[
    /*
     * Override the urlbar so that the universal search code can conditionally
     * intercept key events before they are sent to the existing urlbar key
     * handler code, defined in urlbarBindings.xml.
     */
  ]]>
  <binding id="recommendation-urlbar" extends="chrome://browser/content/urlbarBindings.xml#urlbar">
    <handlers>
      <handler event="keypress" phase="capturing"><![CDATA[
        // If our add-on handles the event, it returns true. Else, it returns
        // false, and the existing XBL key handlers handle the key event.
        return window.universalSearch.urlbar.onKeyPress(event) || this.handleKeyPress(event);
      ]]></handler>
    </handlers>
  </binding>

  <![CDATA[
    /*
    Listen for mouseenter events on the results list.
    TODO: not sure this has to happen in XBL, maybe we can listen in JS?
    */
  ]]>
  <binding id="autocomplete-richlistbox" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete-richlistbox">
    <handlers>
      <handler event="mousemove" phase="capturing"><![CDATA[
        // if the mouse moves over the results list, the recommendation
        // should lose its highlight
        window.universalSearch.popup.onResultsMouseEnter(event);
        return true;
      ]]></handler>
    </handlers>
  </binding>
</bindings>
